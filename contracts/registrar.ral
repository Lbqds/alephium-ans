Contract Registrar(
  registrarOwner: Address,
  ansRegistry: ANSRegistry,
  defaultResolver: DefaultResolver
) extends Constants() {
  event NewNode(node: ByteVec, owner: Address)
  event Transfer(node: ByteVec, oldOwner: Address, newOwner: Address)
  event NewTTL(node: ByteVec, owner: Address, ttl: U256)
  event NewResolver(node: ByteVec, owner: Address, resolverId: ByteVec)

  // namehash("alph")
  const RootNode = #b2453cbabd12c58b21d32b6c70e6c41c8ca2918d7f56c1b88e838edf168776bf
  const MinRentDuration = 2592000000 // 3 months in ms

  fn rentPrice(duration: U256) -> U256 {
    return 1e-15 alph * duration
  }

  @using(preapprovedAssets = true, checkExternalCaller = false)
  pub fn register(
    name: ByteVec,
    owner: Address,
    duration: U256,
    payer: Address
  ) -> () {
    registerWithResolver{payer -> ALPH: tokenRemaining!(payer, ALPH)}(name, owner, duration, payer, Resolver(contractId!(defaultResolver))) // TODO: improve type check
  }

  @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
  pub fn registerWithResolver(
    name: ByteVec,
    owner: Address,
    duration: U256,
    payer: Address,
    resolver: Resolver
  ) -> () {
    assert!(size!(name) != 0, ErrorCodes.InvalidArgs)
    assert!(duration >= MinRentDuration, ErrorCodes.InvalidArgs)

    let currentTs = blockTimeStamp!()
    let label = keccak256!(name)
    let subNode = keccak256!(RootNode ++ label)
    let subNodeContractId = subContractIdOf!(ansRegistry, subNode)
    if (contractExists!(subNodeContractId)) {
      let record = Record(subNodeContractId)
      if (currentTs < record.getTTL()) {
        panic!(ErrorCodes.NameHasBeenRegistered)
      } else {
        record.destroy(subNode)
      }
    }

    let ttl = currentTs + duration
    transferTokenToSelf!(payer, ALPH, rentPrice(duration))

    ansRegistry.newSubNodeRecord{payer -> ALPH: 1 alph}(RootNode, label, owner, ttl, resolver, payer)
    emit NewNode(subNode, owner)
  }

  pub fn unregister(node: ByteVec) -> () {
    let subNodeRecordId = subContractIdOf!(ansRegistry, node)
    let record = Record(subNodeRecordId)
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    record.destroy(node)
  }

  @using(preapprovedAssets = true, assetsInContract = true)
  pub fn renew(node: ByteVec, duration: U256, payer: Address) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    let owner = callerAddress!()
    checkCaller!(owner == record.getOwner(), ErrorCodes.InvalidCaller)
    assert!(duration >= MinRentDuration, ErrorCodes.InvalidArgs)
    let newTTL = record.getTTL() + duration
    record.setTTL(newTTL)
    assert!(newTTL > blockTimeStamp!(), ErrorCodes.InvalidArgs)
    transferTokenToSelf!(payer, ALPH, rentPrice(duration))
    emit NewTTL(node, owner, newTTL)
  }

  pub fn setOwner(node: ByteVec, newOwner: Address) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    let owner = callerAddress!()
    checkCaller!(owner == record.getOwner(), ErrorCodes.InvalidCaller)
    record.setOwner(newOwner)
    emit Transfer(node, owner, newOwner)
  }

  pub fn setResolver(node: ByteVec, resolver: Resolver) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    let owner = callerAddress!()
    checkCaller!(owner == record.getOwner(), ErrorCodes.InvalidCaller)
    record.setResolver(resolver)
    emit NewResolver(node, owner, contractId!(resolver))
  }

  @using(preapprovedAssets = true, assetsInContract = true)
  pub fn withdraw(to: Address, amount: U256) -> () {
    checkCaller!(callerAddress!() == registrarOwner, ErrorCodes.InvalidCaller)
    transferTokenFromSelf!(to, ALPH, amount)
  }
}
