Contract AccountResolver(
  ansRegistry: ANSRegistry,
  registrar: ByteVec,
  accountInfoTemplateId: ByteVec
) extends Constants() implements Resolver {
  event NewAccountInfoCreated(node: ByteVec, pubkey: ByteVec, addresses: ByteVec)
  event AddressUpdated(node: ByteVec, chainId: U256, newAddress: ByteVec)
  event PubkeyUpdated(node: ByteVec, newPubkey: ByteVec)
  event AccountInfoRemoved(node: ByteVec)

  @using(preapprovedAssets = true)
  pub fn newAccountInfo(node: ByteVec, payer: Address, pubkey: ByteVec, addresses: ByteVec) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    let (encodedImmutableFields, encodedMutableFields) = AccountInfo.encodeFields!(Resolver(selfContractId!()), pubkey, addresses)
    copyCreateSubContract!{payer -> ALPH: 1 alph}(
      node,
      accountInfoTemplateId,
      encodedImmutableFields,
      encodedMutableFields
    )
    emit NewAccountInfoCreated(node, pubkey, addresses)
  }

  pub fn setAddress(node: ByteVec, chainId: U256, address: ByteVec) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    AccountInfo(subContractId!(node)).setAddress(chainId, address)
    emit AddressUpdated(node, chainId, address)
  }

  pub fn getAddress(node: ByteVec, chainId: U256) -> ByteVec {
    return AccountInfo(subContractId!(node)).getAddress(chainId)
  }

  pub fn setPubkey(node: ByteVec, pubkey: ByteVec) -> () {
    let record = Record(subContractIdOf!(ansRegistry, node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    AccountInfo(subContractId!(node)).setPubkey(pubkey)
    emit PubkeyUpdated(node, pubkey)
  }

  pub fn getPubkey(node: ByteVec) -> ByteVec {
    return AccountInfo(subContractId!(node)).getPubkey()
  }

  pub fn removeNode(node: ByteVec, refundAddress: Address) -> () {
    checkCaller!(callerContractId!() == registrar, ErrorCodes.InvalidCaller)
    let accountInfoId = subContractId!(node)
    if (contractExists!(accountInfoId)) {
      AccountInfo(accountInfoId).destroy(refundAddress)
      emit AccountInfoRemoved(node)
    }
  }
}
