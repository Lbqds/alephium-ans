Contract PrimaryRegistrar(
  mut registrarOwner: Address,
  recordTemplateId: ByteVec,
  credentialTokenTemplateId: ByteVec
) extends Constants() implements Registrar {
  const MinRentDuration = 2592000000 // 3 months in ms

  fn cost(duration: U256) -> U256 {
    return 1e-15 alph * duration
  }

  @using(preapprovedAssets = true)
  fn createCredentialToken(path: ByteVec, name: ByteVec, payer: Address) -> ByteVec {
    let (tokenImmFields, tokenMutFields) = CredentialToken.encodeFields!(selfContractId!(), name) // TODO: add the ANS prefix
    return copyCreateSubContractWithToken!{payer -> ALPH: 1 alph}(
      path,
      credentialTokenTemplateId,
      tokenImmFields,
      tokenMutFields,
      1,
      payer
    )
  }

  fn preRegister(node: ByteVec, currentTs: U256) -> () {
    let recordId = subContractId!(node)
    if (contractExists!(recordId)) {
      let record = PrimaryRecord(recordId)
      let ttl = record.getTTL()
      assert!(currentTs >= ttl, ErrorCodes.NameHasBeenRegistered)
      CredentialToken(record.getCredentialTokenId()).destroy(record.getRefundAddress())
      record.destroy()
    }
  }

  @using(preapprovedAssets = true, assetsInContract = true, checkExternalCaller = false)
  pub fn register(
    name: ByteVec,
    owner: Address,
    payer: Address,
    duration: U256
  ) -> () {
    assert!(size!(name) != 0, ErrorCodes.InvalidArgs)
    assert!(isAssetAddress!(payer), ErrorCodes.ExpectAssetAddress)
    assert!(duration >= MinRentDuration, ErrorCodes.InvalidArgs)

    let node = keccak256!(name)
    let currentTs = blockTimeStamp!()
    preRegister(node, currentTs)

    transferTokenToSelf!(payer, ALPH, cost(duration))

    let ttl = currentTs + duration
    let credentialTokenPath = node ++ u256To32Byte!(ttl)
    let credentialTokenId = createCredentialToken{payer -> ALPH: 1 alph}(credentialTokenPath, name, payer)

    let (recordImmFields, recordMutFields) = PrimaryRecord.encodeFields!(
      selfContractId!(),
      owner,
      ttl,
      payer,
      credentialTokenId
    )
    copyCreateSubContract!{payer -> ALPH: 1 alph}(
      node,
      recordTemplateId,
      recordImmFields,
      recordMutFields
    )
    emit NameRegistered(name, owner, ttl)
  }

  @using(preapprovedAssets = true, assetsInContract = true)
  pub fn renew(name: ByteVec, payer: Address, duration: U256) -> () {
    assert!(isAssetAddress!(payer), ErrorCodes.ExpectAssetAddress)
    assert!(duration >= MinRentDuration, ErrorCodes.InvalidArgs)

    let node = keccak256!(name)
    let record = PrimaryRecord(subContractId!(node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)

    let currentTs = blockTimeStamp!()
    let currentTTL = record.getTTL()
    assert!(currentTs < currentTTL, ErrorCodes.NameHasExpired)

    transferTokenToSelf!(payer, ALPH, cost(duration))

    let credentialTokenId = record.getCredentialTokenId()
    burnToken!(payer, credentialTokenId, 1)
    CredentialToken(credentialTokenId).destroy(payer)

    let newTTL = currentTTL + duration
    let credentialTokenPath = node ++ u256To32Byte!(newTTL)
    let newCredentialTokenId = createCredentialToken{payer -> ALPH: 1 alph}(credentialTokenPath, name, payer)
    record.setTTL(newTTL)
    record.setCredentialTokenId(newCredentialTokenId)

    emit NameRenewed(name, newTTL)
  }

  @using(preapprovedAssets = true, assetsInContract = true)
  pub fn withdraw(to: Address, amount: U256) -> () {
    checkCaller!(callerAddress!() == registrarOwner, ErrorCodes.InvalidCaller)
    transferTokenFromSelf!(to, ALPH, amount)
  }

  @using(updateFields = true)
  pub fn updateRegistrarOwner(newOwner: Address) -> () {
    checkCaller!(callerAddress!() == registrarOwner, ErrorCodes.InvalidCaller)
    registrarOwner = newOwner
  }
}
