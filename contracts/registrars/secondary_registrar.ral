Contract SecondaryRegistrar(primaryRegistrar: PrimaryRegistrar, recordTemplateId: ByteVec) extends Constants() {
  @using(preapprovedAssets = true, checkExternalCaller = false)
  pub fn register(
    name: ByteVec,
    owner: Address,
    payer: Address,
    credentialTokenId: ByteVec,
    ttl: U256
  ) -> () {
    assert!(size!(name) != 0, ErrorCodes.InvalidArgs)
    assert!(isAssetAddress!(payer), ErrorCodes.ExpectAssetAddress)

    let node = keccak256!(name)
    let credentialTokenPath = node ++ u256To32Byte!(ttl)
    let expectedCredentialTokenId = subContractIdOf!(primaryRegistrar, credentialTokenPath)
    assert!(credentialTokenId == expectedCredentialTokenId, ErrorCodes.InvalidCredentialToken)
    assert!(tokenRemaining!(payer, credentialTokenId) == 1, ErrorCodes.InvalidCredentialToken)

    let secondaryRecordId = subContractId!(node)
    if (contractExists!(secondaryRecordId)) {
      let record = SecondaryRecord(secondaryRecordId)
      assert!(record.getTTL() < ttl, ErrorCodes.InvalidCredentialToken)
      record.destroy()
    }

    let (encodedImmutableFields, encodedMutableFields) = SecondaryRecord.encodeFields!(selfContractId!(), owner, ttl, payer)
    copyCreateSubContract!{payer -> ALPH: 1 alph}(
      node,
      recordTemplateId,
      encodedImmutableFields,
      encodedMutableFields
    )
  }
}