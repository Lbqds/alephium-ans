Contract ANSRegistry(mut admin: Address, recordTemplateId: ByteVec) extends Constants() {
  @using(updateFields = true)
  pub fn updateAdmin(newAdmin: Address) -> () {
    checkCaller!(callerAddress!() == admin, ErrorCodes.InvalidCaller)
    admin = newAdmin
  }

  @using(preapprovedAssets = true)
  pub fn newNode(node: ByteVec, ownerContractId: ByteVec) -> () {
    checkCaller!(callerAddress!() == admin, ErrorCodes.InvalidCaller)
    assert!(contractExists!(ownerContractId), ErrorCodes.ContractNotExists)
    let (encodedImmutableFields, encodedMutableFields) = Record.encodeFields!(
      ownerContractId,
      contractIdToAddress!(ownerContractId),
      1 << 255,
      Resolver(#),
      admin
    )
    copyCreateSubContractWithToken!{admin -> ALPH: 1 alph}(
      node,
      recordTemplateId,
      encodedImmutableFields,
      encodedMutableFields,
      1
    )
  }

  @using(preapprovedAssets = true)
  pub fn newSubNodeRecord(
    node: ByteVec,
    label: ByteVec,
    owner: Address,
    ttl: U256,
    resolver: Resolver,
    payer: Address
  ) -> () {
    let record = Record(subContractId!(node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    assert!(ttl <= record.getTTL(), ErrorCodes.InvalidArgs)
    assert!(isAssetAddress!(payer), ErrorCodes.ExpectAssetAddress)

    let (encodedImmutableFields, encodedMutableFields) = Record.encodeFields!(
      record.getRegistrar(),
      owner,
      ttl,
      resolver,
      payer
    )
    let subNode = keccak256!(node ++ label)
    copyCreateSubContractWithToken!{payer -> ALPH: 1 alph}(
      subNode,
      recordTemplateId,
      encodedImmutableFields,
      encodedMutableFields,
      1
    )
  }
}
