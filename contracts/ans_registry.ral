Contract ANSRegistry(mut admin: Address, recordTemplateId: ByteVec) extends Constants() {
  @using(updateFields = true)
  pub fn updateAdmin(newAdmin: Address) -> () {
    checkCaller!(callerAddress!() == admin, ErrorCodes.InvalidCaller)
    admin = newAdmin
  }

  @using(preapprovedAssets = true)
  pub fn newNode(node: ByteVec, ownerContractId: ByteVec) -> () {
    checkCaller!(callerAddress!() == admin, ErrorCodes.InvalidCaller)
    let ownerAddress = contractIdToAddress!(ownerContractId)
    let maxTTL = 1 << 255
    let encodedImmutableFields = Record.encodeImmFields!(ownerContractId, admin)
    let encodedMutableFields = Record.encodeMutFields!(ownerAddress, maxTTL, #)
    copyCreateSubContractWithToken!{admin -> ALPH: 1 alph}(
      node,
      recordTemplateId,
      encodedImmutableFields,
      encodedMutableFields,
      1
    )
  }

  @using(preapprovedAssets = true)
  pub fn setSubNodeRecord(
    node: ByteVec,
    label: ByteVec,
    owner: Address,
    ttl: U256,
    resolver: ByteVec,
    payer: Address
  ) -> () {
    let record = Record(subContractId!(node))
    checkCaller!(callerAddress!() == record.getOwner(), ErrorCodes.InvalidCaller)
    assert!(ttl <= record.getTTL(), ErrorCodes.InvalidArgs)
    assert!(isAssetAddress!(payer), ErrorCodes.ExpectAssetAddress)
    let subNode = keccak256!(node ++ label)
    let encodedImmutableFields = Record.encodeImmFields!(record.getRegistrar(), payer)
    let encodedMutableFields = Record.encodeMutFields!(owner, ttl, resolver)
    copyCreateSubContractWithToken!{payer -> ALPH: 1 alph}(
      subNode,
      recordTemplateId,
      encodedImmutableFields,
      encodedMutableFields,
      1
    )
  }
}
